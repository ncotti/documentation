{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"My docs","text":"<p>Placeholder text. </p>"},{"location":"about/","title":"About","text":"<p>About what anyways?</p>"},{"location":"gdb/","title":"GDB","text":"<p>The GNU Debugger (GDB) is a powerful tool that allows to inspect the state of an executing program.</p> <p>The documentation is organized as follows:</p> <ul> <li>Tutorial: Run a quick demo of GDB to get the feeling of it.</li> <li>Reference: A quick list of the most used commands.</li> <li>How-to guides: Check for an specific problem or use case of gdb.</li> </ul>"},{"location":"gdb/reference/","title":"GDB Reference","text":"<p>In this document each of the most common GDB commands are detailed. For a full list of commands, please consult the bibliography.</p>"},{"location":"gdb/reference/#layout-configuration-and-startup-commands","title":"Layout, configuration and startup commands","text":"<p>Start GDB with a compiled binary having used the <code>-g</code> flag with:</p> <pre><code>gdb [binary_file]\ngdb -x [script.gdb] [binary_file]\n</code></pre> <p>GDB will always execute the commands in the <code>.gdbinit</code>, regardless of the usage of the <code>-x</code> flag.</p> <p>Quit the debugger with</p> <pre><code>(gdb) q[uit]\n</code></pre> <p>The layout of the debugger is configurable. You can see your source code or the CPU registers by typing the following commands, or by activating the eXtra Awesome mode (<code>Ctrl + x; a</code>).</p> <pre><code>(gdb) lay[out] src\n(gdb) lay[out] regs\n</code></pre> <p>Refresh the display or change the focus window (the focused window is the one that responds to the arrow keys for navigation).</p> <pre><code>(gdb) ref[resh]\n(gdb) foc[us] &lt;layout_selected&gt;\n</code></pre> <p>The program won't run until said so. To set command line arguments, type:</p> <pre><code>(gdb) set args [arg_list ...]\n(gdb) r[un]\n</code></pre> <p>Help with any command can be printed out with:</p> <pre><code>(gdb) h[elp] [command]\n</code></pre>"},{"location":"gdb/reference/#flow-control-commands","title":"Flow control commands","text":"<p>Continue the program's normal operation. The flow of execution is usually stopped by a breakpoint or a watchpoint.</p> <pre><code>(gdb) c[ontinue]\n</code></pre> <p>Go directly to the next line of code in the current file, passing over function calls.</p> <pre><code>(gdb) n[ext]\n</code></pre> <p>Step into the next line of code to be executed, even entering function calls.</p> <pre><code>(gdb) s[tep]\n</code></pre> <p>Finish execution of the current function, and go to the next line of code of the calling script.</p> <pre><code>(gdb) fin[ish]\n</code></pre>"},{"location":"gdb/reference/#breakpoints-and-watchpoints","title":"Breakpoints and watchpoints","text":"<p>A breakpoint can be put at the beginning of a function call or in any line number in a file. All breakpoints get assigned a breakpoint number for future reference. If the file name is omitted, it will use the scope of the current file.</p> <pre><code>(gdb) b[reak] [file_name:]function_name|line_number\n</code></pre> <p>Conditional breakpoints that use the program's variables and simple mathematical expressions can be set with an if statement:</p> <pre><code>(gdb) break [file_name:]function_name|line_number [if condition]\n</code></pre> <p>A watchpoint can be put over a variable and it stops execution of the code every time the content of that memory address changes.</p> <pre><code>(gdb) wat[ch] variable_name\n</code></pre> <p>List all the info of currently active breakpoints:</p> <pre><code>(gdb) i[nfo] b[reak]\n\nNum  Type        Disp  Enb  Address  What\n1    breakpoint  keep  y    0xFFFF   in main at primec.c:34\n</code></pre> <p>Delete a breakpoint using the breakpoint number, or delete all breakpoints if no number is specified.</p> <pre><code>(gdb) d[elete] [breakpoint_number ...]\n</code></pre> <p>Disable or enable a breakpoint:</p> <pre><code>(gdb) dis[able] [breakpoint_number ...]\n(gdb) en[able] [breakpoint_number ...]\n</code></pre> <p>Ignore a breakpoint until it has been crossed <code>x</code> times.</p> <pre><code>(gdb) ign[ore] [breakpoint_number ...] [x]\n</code></pre> <p>Create a temporary breakpoint that will be deleted after being reached once.</p> <pre><code>(gdb) tb[reak] [function_name]\n</code></pre>"},{"location":"gdb/reference/#displaying-information","title":"Displaying information","text":"<p>The info command displays all the information needed at the current step in execution. Some notable mentions are:</p> <pre><code>(gdb) i[nfo] r[egisters]    # Print all registers, same info as in layout regs\n(gdb) i[nfo] lo[cals]       # Print all local variables with their values\n(gdb) i[nfo] ar[gs]         # Print arguments passed to function.\n</code></pre> <p>Print the variables' values in scope with:</p> <pre><code>(gdb) p[rint] [variable_name]\n(gdb) p vector[index]\n(gdb) p *vector@[len]\n</code></pre> <p>Display a variable's value each time the execution stops with the <code>display</code> command.</p> <pre><code>(gdb) display [variable_name]\n(gdb) undisplay [variable_name]\n</code></pre> <p>Print the backtrace of the program, which includes all the function calls that needed to be made to be where you are, with its arguments and all the variables in scope.</p> <pre><code>(gdb) bt full\n</code></pre> <p>Use a printf just like in C to obtain nicer outputs.</p> <pre><code>(gdb) printf \"some_text\\n\"\n</code></pre>"},{"location":"gdb/reference/#gdb-scripting","title":"GDB Scripting","text":"<p>Enable logging to a file:</p> <pre><code>set logging enabled [on|off]\nset logging file [file_name]\nset logging overwrite [on|off]\n</code></pre> <p>Specify commands to be executed when a breakpoint is reached:</p> <pre><code>break [file_name:][function_name|line_number]\n    commands\n    # actual commands, usually printing variables and memory values\nend\n</code></pre> <p>Avoid downloading debug info form URLs:</p> <pre><code>set debuginfod enabled off\n</code></pre>"},{"location":"gdb/reference/#bibliography","title":"Bibliography","text":"<ul> <li> <p>gdb QuickStart.</p> </li> <li> <p>gdb Cheatsheet.</p> </li> <li> <p>GDB: The GNU Project Debugger.</p> </li> </ul>"},{"location":"gdb/tutorial/","title":"GDB Tutorial","text":"<p>In this tutorial we will compile, execute and debug a simple C code.</p> <p>Let's first take a look at the code we will be debugging. This code prints the sum of the first prime numbers.</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint add_array(int *arr, int length) {\n    int sum = 0;\n    for(int i=0; i&lt;length; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n\nint is_prime(int x) {\n    if(x &lt; 2) {\n        return 0;\n    } else if(x == 2) {\n        return 1;\n    } else if(x % 2 == 0) {\n        return 0;\n    }\n    for(int i=3; i&lt;=sqrt(x); i+=2) {\n        if(x % i == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint *get_first_primes(int number_of_primes) {\n    int* result = (int*) malloc(sizeof(int) *number_of_primes);\n    int i=1, x=3;\n\n    result[0] = 2;\n    while(i &lt; number_of_primes) {\n        if(is_prime(x)) {\n            result[i] = x;\n            i++;\n        }\n        x += 2;\n    }\n    return result;\n}\n\nint main(int argc, char **argv) {\n    int prime_number_qtty = 3;\n    int sum;\n    int* primes;\n\n    if(argc == 2) {\n        prime_number_qtty = atoi(argv[1]);\n    }\n    primes = get_first_primes(prime_number_qtty);\n\n    sum = add_array(primes, prime_number_qtty);\n    printf(\"&gt;&gt;&gt; The sum of the first %d prime numbers is %d.\\n\", \n        prime_number_qtty, sum);\n    free(primes);\n    return 0;\n}\n</code></pre> <p>We will be using GCC to compile it and we need to add the <code>-g</code> flag in order to include the debug information in the binary file. Therefore, create a file called <code>primes.c</code> with the contents of the previous code snippet and then compile with:</p> <pre><code>gcc -Wall -g primes.c -lm\n</code></pre> <p>Let's see that our program works as intended by executing it:</p> <pre><code>./a.out\n&gt;&gt;&gt; The sum of the first 3 prime numbers is 10.\n./a.out 5\n&gt;&gt;&gt; The sum of the first 5 prime numbers is 28.\n</code></pre> <p>Before executing GDB, we need to first setup a few configurations to avoid some warnings showing up:</p> <pre><code>mkdir -p ~/.config/gdb\necho \"set auto-load safe-path /\" &gt;&gt; ~/.config/gdb/gdbinit\necho \"set debuginfod enabled off &gt; .gdbinit\n</code></pre> <p>Let's execute GDB now. you should see a bunch of messages, and the last ones are:</p> <pre><code>gdb a.out\n...\nReading symbols from a.out...\n(gdb) \n</code></pre> <p>Note</p> <p>At any time, you can quit by typing <code>(gdb) quit</code> or <code>(gdb) q</code>.</p> <p>This is the interactive GDB terminal, where we can run our program and see how it executes in real time.</p> <p>The first thing that should be done after starting any GBD terminal is to activate the eXtra Awesome mode, with the combination of keys <code>Ctrl + x; a</code> (first Ctrl + x, then a). You should now see the code and the GDB terminal at once.</p> <p>Lets start by running our program with:</p> <pre><code>(gdb) run\n...\n&gt;&gt;&gt; The sum of the first 3 prime numbers is 10.\n...\n(gdb) set args 5\n(gdb) run\n...\n&gt;&gt;&gt; The sum of the first 3 prime numbers is 28.\n...\n</code></pre> <p>As you can see, our program ran and printed the same message as if it was run from the console. Now, let's try running the code again, but this time step by step. While running these commands, you will first set a breakpoint at the start of the function <code>main</code>, in the file <code>primes.c</code>. Later, you will run the program, and execute the <code>next</code> line of code on that file, skipping the internal execution of the functions. When reaching the call to the function <code>add_array</code>, you will <code>step</code> into the function, and execute some of its lines before <code>finish</code> its execution, and returning to the caller. Finally, we <code>continue</code> execution until the next breakpoint. Since there are none, the program ends.</p> <pre><code>(gdb) break primes.c:main\n(gdb) run\n(gdb) next\n(gdb) n\n(gdb) n\n(gdb) n\n(gdb) step\n(gdb) n\n(gdb) \n(gdb) \n(gdb) \n(gdb) finish\n(gdb) n\n(gdb) n\n(gdb) continue\n</code></pre> <p>Note</p> <p>An empty terminal line like <code>(gdb)</code> means to press enter. It is a shortcut for repeating the last command. The same applies for using a singe letter like <code>n</code> instead of <code>next</code>.</p> <p>We traversed all the aspects of our code, but we still didn't see any of the variables' values, only which lines were executed. We know that our code adds the first prime numbers, but we would like to check that the numbers added are actually prime numbers.</p> <p>To do that, we will first, set a breakpoint in the \"add_array\" function, and <code>watch</code> (add a watchpoint) to the variable sum. This will pause the execution of the program each time that variable changes, and print its value. Besides, we will <code>print</code> the value of the prime number array <code>arr[i]</code> that we are adding each time and finally, we will print the whole primes array.</p> <pre><code>(gdb) break primes.c:add_array\n(gdb) set args 10\n(gdb) run\n(gdb) watch sum\n(gdb) c\n(gdb) c\n(gdb) c\n(gdb) print arr[i]\n(gdb) c\n(gdb) delete 2\n(gdb) finish\n(gdb) print *primes@prime_number_qtty\n(gdb) c\n(gdb) quit\n</code></pre> <p>In this tutorial we covered the basics of using the GNU Debugger. We executed our code line by line and saw the values of the variables as they were changing in real time.</p>"},{"location":"gdb/how-to-guides/how_to_create_a_gdb_script/","title":"How to create a GDB script","text":"<p>This guides shows you how to write a GDB script to automate a debugging session.</p> <p>You can execute GDB with a script using the <code>-x</code> flag, or it will be called automatically if you name it  like <code>.gdbinit</code>.</p> <p>Although all the commands used for interactive debugging can still utilized, while writing a script one must consider two things:</p> <ol> <li>The output will be printed to a file, not to stdout.</li> <li>The debugging session can't block, it should start and end.</li> </ol> <p>Because of (1), you should first log the output to a file instead of stdout.</p> <pre><code>set debuginfod enabled off\nset logging file [file_name]\nset logging overwrite on\n</code></pre> <p>When you set a breakpoint or watchpoint, you need to tell the debugger what commands need to be executed each time it stops, like so:</p> <pre><code>break [file_name:][function_name|line_number]\n    commands\n    # actual commands, usually printing variables and memory values\nend\n</code></pre> <p>After all the breakpoints and actions have been set, enable the logging and run the debugging session:</p> <pre><code>set logging enabled on\nrun\nset logging enabled off\nquit\n</code></pre> <p>And that's how you write a GDB script. For more advanced commands, consult the reference section.</p>"}]}